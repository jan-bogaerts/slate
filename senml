<h1 id='senml-library-documentation'>SenML library documentation</h1><h2 id='introduction'>Introduction</h2>
<p>This library aids you in the creation of <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12">senml documents</a> which can be used to transport data in a uniform way to and from devices using a communication protocol of your choice.</p>
<h2 id='key-features'>key features</h2>
<ul>
<li>The library is optimized for devices with restricted memory requirements. </li>
<li>Object oriented design. </li>
<li>built in support for <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-12.1">senml&#39;s unit registry</a> </li>
<li>extendible for new data types</li>
<li>makes use of (but doesn&#39;t restrict to) KPN&#39;s predefined list of record names.</li>
<li>direct support to read/write in cbor format.</li>
<li>automatically adjusts record values with respect to base value &amp; base sum.</li>
</ul>
<h2 id='getting-started'>getting started</h2><h3 id='installation'>installation</h3>
<ul>
<li>You can get the library from here.</li>
<li>Installation:

<ul>
<li><em>arduino</em>: Follow <a href="https://www.arduino.cc/en/Guide/Libraries">these instructions</a> to install the library in the arduino ide.</li>
<li>mbed: [todo]</li>
<li>python: [todo]</li>
</ul></li>
</ul>
<h3 id='usage'>usage</h3>
<p>First off, you need to include the library header in your sketch or application. So put the following line somewhere near the top of your code:</p>
<pre class="highlight plaintext"><code>#include &lt;kpnSenml.h&gt;
</code></pre>
<p>Next up, you have to declare a variable of type &#39;SenMlPack&#39;, which will function as the document that contains all your measurement values.  This can be a global or local to a function.</p>
<pre class="highlight plaintext"><code>SenMlPack doc("device_name");
</code></pre>
<p>If you are building up a senml message than you always have to specify the base name of the senml document. Other parameters can be:
- the base unit
- a callback function used to relay actuator commands found during parsing of a senml message.  </p>

<p>Measurement values are added to the document through objects of the type SenMlRecord<T> or it&#39;s inheritors. These can also be global, statically declared objects or they can be local to a function. Here ar some examples:</p>
<pre class="highlight plaintext"><code>void loop(){
    int val = analogRead(A1);  
    SenMlNumericRecord senmlVal(SENML_TEMPERATURE, SENML_CELSIUS, val);
    doc.add(senmlVal);                      
    doc.toJson(Serial);
}
</code></pre>
<p>This code snippet reads the value from a pin, stores this measument in a numeric senml record as temperature in degrees celsius and adds this record to the document. Finally, the document object renders a json string to the Serial output.<br>
At the end of the function, the record is destroyed cause it goes out of scope. This will automatically remove it from the document, so on the next run, the document will be empty again and a new record can be added.<br>
The senmlpack object always renders to a stream. This way, a large string can directly be written to the communication device without consuming too much memory.  If you would like to build up the string in RAM, you can use a library like <a href="https://github.com/Chris--A/PrintEx#printex-library-for-arduino-">PrintEx</a>. </p>

<p>For more examples, see <a href="#examples">here</a></p>
<h2 id='detailed-description'>Detailed description</h2><h3 id='memory-optimzations'>Memory optimzations</h3><h3 id='object-oriented-class-structure'>Object oriented: class structure</h3>
<p><img src="/images/./librarydesign.png" alt="class diagram" /><br>
The root class for all senml documents is called &#39;SenMlPack&#39;.  It defines the base name, base unit and base time of the document.  This object can also contain 0, 1 or more SenMlRecords where each record represents a single measurement (or command).<br>
The library contains a pre-defined SenMlRecord class for the most common data types: string, boolean and numeric. But, since the base record class is a template, you can create new SenMlRecord classes for more specific data types such as an int32.<br>
It&#39;s also possible to create more complex record types such as for location data where latitude, longitude and altitude are combined in 1 object. This can be done by inheriting from one of the predefined record classes and overwriting the required functions.  See <a href="#customRecordTypes">here</a> for more info.</p>
<h3 id='names-and-units'>names and units</h3>
<p>The library defines an enum for all of senml&#39;s supported units (as in &#39;kilogram&#39;, &#39;meter&#39;,...). This makes it easier to keep compliance with the <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12">senml specifications</a> as you don&#39;t have to worry about the exact unit symbols: the library takes care of this.<br>
Similarly, the library also provides an enum with all the record names that the KPN network supports.<br>
Although it is possible that you assign your own name to a record, it is recommended to use KPN&#39;s naming convention as this allows data to be addressed in a more semantical manner.<br>
Both parameters are supplied through the constructor of the SenMlRecords. For the name of the record, you have the option to use the enum or to specify your own string.</p>
<h3 id='associating-records-with-a-document'>associating records with a document</h3>
<p>Internally, the senml object uses a linked list to store the records that it manages.  You can add records to the document with the function <a href="#add">add</a>. This can be done statically (add once at startup and never remove) for devices that will always send out the same document structure with the same records. Alternatively, you can dynamically add records to the document as your application progresses. A common use case for this method is for situations where the device does not have network connectivity at the moment that the measurement is taken, but instead, takes a number of measurements, and, when a connection is available, uploads all the measurements at once.  This method is useful to minimize the number of communication packets that a device uses by grouping measurements.<br>
For documents that work with a dynamically sized list of records, you can <a href="#clear">clear</a> out the list once the data has been sent.<br>
Alternatively ,when SenMlRecords go out of scope or are deleted, they remove themselves automatically from their root document.</p>
<h3 id='rendering-json'>Rendering json</h3>
<p>The SenMl document is responsible for rendering the json structure.  This is done with the (render)[#render] function which expects a stream object as parameter as the destination where the json string will be sent to.  By using a stream, it is possible to immediately send out the data to the communication module (lora radio, wifi module,...) without having to build the entire string in memory.  This is useful for devices with memory constraints.<br>
If you want to render to a string, you can work with a library such as <a href="https://github.com/Chris--A/PrintEx#printex-library-for-arduino-">PrintEx</a> which provides a streaming object that can write to a memory buffer.  See <a href="#stream-to-string">here</a> for an example.<br>
As a side note: it&#39;s also possible to render the string notation of a single SenMlRecord since each class exposes the function to render the json value</p>
<h3 id='parsing-json'>parsing json</h3>
<p>the library is also able to receive a json string from a stream and generate events based on the content of the senml-json data. This way, you can use senml messages for sending actuator commands (send instructions to your devices).<br>
Just like for rendering, the library is able to work directly with stream objects such as an <a href="https://www.arduino.cc/reference/en/language/functions/communication/serial">arduino Serial class</a> so that a minimum amount of memory has to be spend for parsing incoming data.
To process a senml message and retrieve the values, you can use the <a href="#parse">parse</a> function.  The values found in the message get passed to your application by means of callback functions that you attach to the SenMlPacket object and/or the SenMlRecords.<br>
If you have a static list of records in your document, you can declare all the objects once, at the beginning, just like for rendering. The only difference here is that you have to attach a callback to each record for which you want to receive events.  During parsing, each callback will be executed when the record is found in the data.  Check out <a href="#statically-declared-actuators">here</a> for an example.<br>
If your device will receive a dynamic list of records, than you should attach a callback to the root SenmlPack document. This function gets called for every record found in the data. Besides the actual value, which is passed on as a generic void pointer, you also receive the name of the record and the data type so that your application can figure out what it should do for the specified data.  Check out <a href="#dynamically-declared-actuators">here</a> for an example.
You can also mix the 2 approaches: use a generic callback function at the root level for dynamic lists or for catching unsupported records and a specific callback for each record type that you know should be in the data.<br>
Note: it is up to you to determine if all expected records were present in the data or not.  The library does not check for this, but only passes on the values it can find to your applications.</p>
<h3 id='supporting-binary-formats'>supporting binary formats</h3>
<p>The library is able to render and parse cbor binary data through a 3th party library called <a href="https://github.com/RIOT-OS/RIOT">riot</a>. The senMlPacket class exposes a function <a href="#renderCbor">toCbor</a> which will generate a byte stream and a function <a href="#parseCbor">fromCbor</a> for handling messages that were send to your device. See <a href="#cbor-support">here</a> for some examples.</p>
<h2 id='implementing-your-own-record-types'><a name="customRecordTypes"></a> implementing your own record types</h2>
<p>It is possible to create your own, custom SenMlRecord classes. This can be used to provide support for more complex data types than already available in the library.  For instance, if you would like to store location info (lat/lng/alt) in a single record instead of 3 individual ones, than you could create a new class that inherits from the SenMlRecord template, provide a struct as template parameter and re-implement the rendering and parsing functions.<br>
You can find an example <a href="#custom-record">here</a>.</p>
<h2 id='api'>api</h2><h3 id='senmlbase'>SenMLBase</h3>
<p>This is the base class for all class types in the senml library. It defines an interface that is common to all objects. Internally, it also lays down the foundation for the relationship between a pack/document and it&#39;s records.</p>
<h4 id='public'>public</h4><h5 id='tojson'>toJson</h5><pre class="highlight plaintext"><code>void toJson(Stream* output)
</code></pre>
<p>Render the object to the specified stream as a json string.</p>

<p><strong><em>parameters</em></strong>: output (Stream*) a pointer to a stream object. Data will be written to it.<br>
<strong><em>returns</em></strong>: nothing</p>
<h5 id='fromjson'>fromJson</h5><pre class="highlight plaintext"><code>bool fromJson(Stream* input)
</code></pre>
<p>Reads a json string from the input and converts it into the data structure that the object represents. If the object is a SenMlPack, than it reads out an entire senml data structure, including all the child records.  Records with an unknown name are skipped, unless they end with &#39;_&#39; which produces an error (<a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.4">as per spec</a>).<br>
If the object is a SenMLRecord, than it only reads out the data for that record.<br>
If the object was created with a callback function, than this will be called for each record that is found in the input.  </p>

<p><strong><em>parameters</em></strong>: input (Stream*) a pointer to a stream object. Data will be read from it.<br>
<strong><em>returns</em></strong>: boolean: If the input stream can&#39;t be read, then the function will return false, otherwise, it returns .true</p>
<h5 id='tocbor'>toCbor</h5><pre class="highlight plaintext"><code>void toCbor(Stream* output)
</code></pre>
<p>Render the object to the specified stream as a binary cbor blob.</p>

<p><strong><em>parameters</em></strong>: output (Stream*) a pointer to a stream object. Data will be written to it.<br>
<strong><em>returns</em></strong>: nothing</p>
<h5 id='fromcbor'>fromCbor</h5><pre class="highlight plaintext"><code>bool fromCbor(Stream* input)
</code></pre>
<p>Reads a binary cbor blob from the input and converts it into the data structure that the object represents. If the object is a SenMlPack, than it reads out an entire senml data structure, including all the child records.   Records with an unknown name are skipped, unless they end with &#39;_&#39; which produces an error (<a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.4">as per spec</a>).<br>
If the object is a SenMLRecord, than it only reads out the data for that record.<br>
If the object was created with a callback function, than this will be called for each record that is found in the input.  </p>

<p><strong><em>parameters</em></strong>: input (Stream*) a pointer to a stream object. Data will be read from it.<br>
<strong><em>returns</em></strong>: boolean: If the input stream can&#39;t be read, then the function will return false, otherwise, it returns .true</p>
<h5 id='getjsonlength'>getJsonLength</h5><pre class="highlight plaintext"><code>int getJsonLength()
</code></pre>
<p>Returns the number of characters that this object would consume in json representation.<br>
This is a convenience function that allows you to reserve the exact buffer size for streaming to memory.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>: int: The number of characters that a json string would consume, not including the 0 terminator.</p>
<h4 id='protected'>protected</h4><h5 id='getnext'>getNext</h5><pre class="highlight plaintext"><code>SenMLBase* getNext()
</code></pre>
<p>returns the next object in the linked list.<br>
Note: this is usually a SenMlRecord object, but can also be a SenMlPack object, when results from multiple devices are combined in 1 data structure, as described in the section <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-5.1.6">collection of resources</a> of the senml specs.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>: SenMLBase*: A pointer to the next record in the linked list or NULL if there is no next item.</p>
<h5 id='setnext'>setNext</h5><pre class="highlight plaintext"><code>bool setNext(SenMLBase* next)
</code></pre>
<p>Store the specified item as the next reference in the linked list. If there was a previous value, this is overwritten, no memory is freed.<br>
Note: this is usually a SenMlRecord object, but can also be a SenMlPack object, when results from multiple devices are combined in 1 data structure, as described in the section <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-5.1.6">collection of resources</a> of the senml specs.</p>

<p><strong><em>parameters</em></strong>: next (SenMLBase*): a pointer to a SenMl object that should become the next item in the list.<br>
<strong><em>returns</em></strong>: None</p>
<h3 id='senmlpack'>SenMlPack</h3>
<p>This class represents a single document containing 1 or more snml records (aka measurements).<br>
The records are stored in a linked list. To retrieve the first element, use the <a href="#getnext">getNext</a> function.</p>
<h4 id='constructors'>constructors</h4><pre class="highlight plaintext"><code>SenMlPack::SenMlPack(const char* baseName)
</code></pre>
<p>Create the object with a base name (bs field).</p>
<pre class="highlight plaintext"><code>SenMlPack::SenMlPack(const char* baseName, PACKCALLBACK callback)
</code></pre>
<p>Create the object with a base name (bs field) and a callback function for parsing data (actuator commands).<br>
Objects created with this constructor can be used for creating senml messages and parsing them.  When used for parsing, the base-name of the incomming message will be compared to the one specified during construction. If they don&#39;t match, the validation of the document fails.</p>
<pre class="highlight plaintext"><code>SenMlPack::SenMlPack(const char* baseName, const char* baseUnit)
</code></pre>
<p>Create the object with a base name (bs field) and base unit (bu).</p>
<pre class="highlight plaintext"><code>SenMlPack::SenMlPack(const char* baseName, const char* baseUnit, PACKCALLBACK callback)
</code></pre>
<p>Create the object with a base name (bs field), base unit (bu) and a callback function for parsing data (actuator commands).<br>
Objects created with this constructor can be used for creating senml messages and parsing them.  When used for parsing, the base-name and base-unit of the incomming message will be compared to the ones specified during construction. If they don&#39;t match, the validation of the document fails.</p>
<pre class="highlight plaintext"><code>SenMlPack::SenMlPack(PACKCALLBACK callback)
</code></pre>
<p>Create the object with a callback function for parsing data (actuator commands).
This constructor creates an object that can only be used for parsing incoming messages. No checks are done on the data being read.</p>
<h4 id='public-2'>public</h4><h5 id='add'>add</h5><pre class="highlight plaintext"><code>bool add(SenMlRecord&lt;T&gt;* item)
</code></pre>
<p>Adds the specified senml record to the document. The item will be appended to the end of the linked list.<br>
Check the result of the function to see if the operation was successful or not.</p>

<p><strong><em>parameters</em></strong>: item (SenMlRecord<T><em>): a pointer to a SenMl record that needs to be added to the document.<br>
__*returns</em>__: bool: True when the operation was a success, otherwise false.  </p>
<h5 id='clear'>clear</h5><pre class="highlight plaintext"><code>bool clear()
</code></pre>
<p>Clear out the document and remove all the children. 
Children aren&#39;t destroyed, this is up to the developer.<br>
Check the result of the function to see if the operation was successful or not.  </p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>: bool: True when the operation was a success, otherwise false.  </p>
<h5 id='setbn'>setBn</h5><pre class="highlight plaintext"><code>void setBn(const char* name)
</code></pre>
<p>Set the base name. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: name (const char*) : an immutable string.<br>
<strong><em>returns</em></strong>: None  </p>

<p><strong><em>parameters</em></strong>: name (const char*) : an immutable string.<br>
<strong><em>returns</em></strong>: None </p>
<h5 id='getbn'>getBn</h5><pre class="highlight plaintext"><code>const char* getBn()
</code></pre>
<p>Get the base name. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>: const char*: an immutable string.</p>
<h5 id='setbu'>setBu</h5><pre class="highlight plaintext"><code>void setBu(SenmlUnit unit)
</code></pre>
<p>Set the base unit.  see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: name (SenmlUnit) : an enum.<br>
<strong><em>returns</em></strong>: None  </p>
<h5 id='getbu'>getBu</h5><pre class="highlight plaintext"><code>SenmlUnit getBu()
</code></pre>
<p>Get the base unit. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>: SenmlUnit: an enum.  </p>
<h5 id='setversion'>setVersion</h5><pre class="highlight plaintext"><code>void setVersion(unsigned int version)
</code></pre>
<p>Set the version.  see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: version (unsigned int) : the version number of senml spec.<br>
<strong><em>returns</em></strong>: None  </p>
<h5 id='getversion'>getVersion</h5><pre class="highlight plaintext"><code>unsigned int getVersion()
</code></pre>
<p>Get the base version. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>: unsigned int: the version number.</p>
<h3 id='senmlpack-lt-t-gt'>SenMlPack&lt; T&gt;</h3>
<p>A templated version of the senmlPack class which provides support for base value and base sum. The template parameter refers to the value-type (int, double, bool,..) of the base value and sum.</p>
<h4 id='public-3'>public</h4><h5 id='setbv'>setBv</h5><pre class="highlight plaintext"><code>void setBv(T value)
</code></pre>
<p>Set the base value. 
see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: value (T) : the base value.<br>
<strong><em>returns</em></strong>: None  </p>
<h5 id='getbv'>getBv</h5><pre class="highlight plaintext"><code>T getBv()
</code></pre>
<p>Get the base value. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>: T: the base value.</p>
<h5 id='setbs'>setBs</h5><pre class="highlight plaintext"><code>void setBs(T value)
</code></pre>
<p>Set the base sum. 
see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: value (T) : the base value.<br>
<strong><em>returns</em></strong>: None  </p>
<h5 id='getbs'>getBs</h5><pre class="highlight plaintext"><code>T getBs()
</code></pre>
<p>Get the base sum. see the spec on <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.1">base fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>: T: the base value.</p>
<h3 id='senmlrecord-lt-t-gt'>SenMlRecord&lt; T&gt;</h3>
<p>This class represents a single measurement. Besides the value, it also stores the name, optional unit and optional timestamp.<br>
If you want to work directly with this class, you will have to specify a value for the template parameter. This should be a value type (int, float, bool,..). If you want to specify a different data type, you should inherit from this class and re-implement the rendering &amp; parsing functions.<br>
The library already has a number of convenience classes defined for you that map to the json data types: string, boolean, binary data and number, which maps to a double.</p>
<h4 id='constructors-2'>constructors</h4><pre class="highlight plaintext"><code>SenMlRecord::SenMlRecord(KPNSenmlName name)
</code></pre>
<p>Set the record name.  </p>

<p><strong><em>parameters</em></strong>: 
- name (KPNSenmlName) : KPNSenmlName is an enum for all the names supported by the KPN network.</p>
<pre class="highlight plaintext"><code>SenMlRecord::SenMlRecord(const char* name)
</code></pre>
<p>Set the record name.  </p>

<p><strong><em>parameters</em></strong>: 
- name (const char*) : You own custom record name.</p>
<pre class="highlight plaintext"><code>SenMlRecord::SenMlRecord(KPNSenmlName name, SenmlUnit unit)
</code></pre>
<p>Set the record name and unit.  </p>

<p><strong><em>parameters</em></strong>: 
- name (KPNSenmlName) : KPNSenmlName is an enum for all the names supported by the KPN network.
- unit (SenmlUnit): the measurement unit. see the <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-12.1">units registry</a> in the specs for more info.</p>
<pre class="highlight plaintext"><code>SenMlRecord::SenMlRecord(KPNSenmlName name, SenmlUnit unit, T value, double time = NaN)
</code></pre>
<p>Set the record name, unit, value and optionally time stamp.  </p>

<p><strong><em>parameters</em></strong>: 
- name (KPNSenmlName) : KPNSenmlName is an enum for all the names supported by the KPN network.
- unit (SenmlUnit): the measurement unit. see the <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-12.1">units registry</a> in the specs for more info.
- the value that needs to be stored in the record.
- - time (double): optional, the time at which the measurement was performed. Either absolute, or relative to the base time. NaN represents no value.  </p>
<h4 id='public-4'>public</h4><h5 id='set'>set</h5><pre class="highlight plaintext"><code>bool set(T value, double time = NaN)
</code></pre>
<p>Store the specified value in the record. The data type must match the value that was specified for the template parameter of the class. So if you are working with a SenMlRecord<int16> then you should supply an int16 as value.</p>

<p>You can optionally specify a timestamp to go with the measurement. Time is represented in floating point as seconds and values greater than zero represent an absolute time relative to the Unix epoch while values of 0 or less represent a relative time in the past from the current time.</p>

<p>The value NaN represents no timestamp, which is the default value. In this case, no timestamp label will be generated in the json.</p>

<p>Check the result of the function to see if the operation was successful or not.</p>

<p><strong><em>parameters</em></strong>: 
- value (T): the value of the measurement.
- time (double): optional, the time at which the measurement was performed. Either absolute, or relative to the base time. NaN represents no value.  </p>

<p><strong><em>returns</em></strong>: bool: True when the operation was a success, otherwise false.</p>
<h5 id='get'>get</h5><pre class="highlight plaintext"><code>bool get(T&amp; result)
</code></pre>
<p>Returns the value currently stored by the record.</p>

<p><strong><em>parameters</em></strong>: result (T): The current value of the record.<br>
<strong><em>returns</em></strong>: bool: true when there is a value stored in the record, otherwise false.</p>
<h5 id='clearvalue'>clearValue</h5><pre class="highlight plaintext"><code>void clearValue()
</code></pre>
<p>clears the value from the record. See <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.2">regular fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>:  None </p>
<h5 id='settime'>setTime</h5><pre class="highlight plaintext"><code>void setTime(double time)
</code></pre>
<p>Assigns the specified timestamp to the record. Use NaN to remove the timestamp.
See <a href="#set">set</a> for more info on the time value.</p>

<p><strong><em>parameters</em></strong>: time (double): The timestamp to store.<br>
<strong><em>returns</em></strong>: None</p>
<h5 id='gettime'>getTime</h5><pre class="highlight plaintext"><code>bool getTime(double&amp; result)
</code></pre>
<p>Returns the timestamp at which the current value was measured.
See <a href="#set">set</a> for more info on the time value.</p>

<p><strong><em>parameters</em></strong>: result (double): The current timestamp of the record.<br>
<strong><em>returns</em></strong>: bool: true when there is a timestamp stored in the record, otherwise false.</p>
<h5 id='cleartime'>clearTime</h5><pre class="highlight plaintext"><code>void cleaTime()
</code></pre>
<p>clears the time from the record. See <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.2">regular fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>:  None </p>
<h5 id='setsum'>setSum</h5><pre class="highlight plaintext"><code>void setSum(T sum)
</code></pre>
<p>set the sum for the record. See <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.2">regular fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: sum (T): Integrated sum of the values over time.<br>
<strong><em>returns</em></strong>: None</p>
<h5 id='getsum'>getSum</h5><pre class="highlight plaintext"><code>bool getSum(T&amp; value)
</code></pre>
<p>Returns the sum for the record. See <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.2">regular fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: result (T): Integrated sum of the values over time.<br>
<strong><em>returns</em></strong>: bool: true when there is a value stored in the record, otherwise false.</p>
<h5 id='clearsum'>clearSum</h5><pre class="highlight plaintext"><code>void clearSum()
</code></pre>
<p>clears the sum from the record. See <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.2">regular fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>:  None </p>
<h5 id='setupdatetime'>setUpdateTime</h5><pre class="highlight plaintext"><code>void setUpdateTime(unsigned int time)
</code></pre>
<p>set the update time. See <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.2">regular fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: time (unsigned int): Period of time in seconds that represents the maximum time before this sensor will provide an updated reading for a measurement.<br>
<strong><em>returns</em></strong>: None </p>
<h5 id='getupdatetime'>getUpdateTime</h5><pre class="highlight plaintext"><code>bool getUpdateTime(unsigned int* result)
</code></pre>
<p>Returns the update time. See <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.2">regular fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: result (T): Period of time in seconds that represents the maximum time before this sensor will provide an updated reading for a measurement.<br>
<strong><em>returns</em></strong>: bool: true when there is a value stored in the record, otherwise false.  </p>
<h5 id='clearupdatetime'>clearUpdateTime</h5><pre class="highlight plaintext"><code>void clearUpdateTime()
</code></pre>
<p>clears the update time from the record. See <a href="https://tools.ietf.org/html/draft-ietf-core-senml-12#section-4.2">regular fields</a> for more info.</p>

<p><strong><em>parameters</em></strong>: None<br>
<strong><em>returns</em></strong>:  None  </p>
<h2 id='examples'>examples</h2><h3 id='basic'>basic</h3><pre class="highlight plaintext"><code>#include &lt;kpnSenml.h&gt;

SenMlPack doc("device_name");

void init(){

}

void loop(){
    int val = analogRead(A1);  
    SenMlNumericRecord senmlVal(SENML_TEMPERATURE, SENML_CELSIUS, val);
    doc.add(senmlVal);                      
    doc.toJson(Serial);
}
</code></pre><h3 id='stream-to-string'>Stream to string</h3>
<p>from <a href="https://forum.arduino.cc/index.php?topic=411338.msg2831125#msg2831125">this</a> example</p>
<pre class="highlight plaintext"><code>#include &lt;kpnSenml.h&gt;

SenMlPack doc("device_name");

void init(){

}

void loop(){
    int val = analogRead(A1);  
    SenMlNumericRecord senmlVal(SENML_TEMPERATURE, SENML_CELSIUS, val);
    doc.add(senmlVal);                      

    char buffer[50];            
    GString str = buffer;          //Wrap the buffer in a GString, making it printable.
    PrintAdapter streamer = str;   //Convert a Print object to a Stream object.
    doc.toJson(streamer);
    Serial.print(str);
}
</code></pre><h3 id='cbor-support'>Cbor support</h3><pre class="highlight plaintext"><code>#include &lt;kpnSenml.h&gt;

SenMlPack doc("device_name");

void init(){

}

void loop(){
    int val = analogRead(A1);  
    SenMlNumericRecord senmlVal(SENML_TEMPERATURE, SENML_CELSIUS, val);
    doc.add(senmlVal);                      
    doc.toCbor(Serial);
}
</code></pre><h3 id='statically-declared-actuators'>Statically declared actuators</h3><pre class="highlight plaintext"><code>#include &lt;kpnSenml.h&gt;

void onSwitch(bool value){
    digitalWrite(D1, value);
}


SenMlPack doc("device_name");
SenMlBoolRecord senmlVal(SENML_SWITCH, onSwitch);

void init(){
    doc.add(senmlVal);
}

void loop(){
    if(Serial.available()){
        if(doc.fromJson(Serial)){
            Serial.print("end");
        }
    }
}
</code></pre><h3 id='dynamically-declared-actuators'>Dynamically declared actuators</h3><pre class="highlight plaintext"><code>#include &lt;kpnSenml.h&gt;

void onSwitch(bool value){
    digitalWrite(D1, value);
}

void onOtherSenMl(const char* name, const char* unit, BYTE dataType, void* value){
    Serial.print("found unknown record in input: "); Serial.println(name);
}

SenMlPack doc("device_name", onOtherSenMl);
SenMlBoolRecord senmlVal(SENML_SWITCH, onSwitch);

void init(){
    doc.add(senmlVal);
}

void loop(){
    if(Serial.available()){
        if(doc.fromCbor(Serial)){
            Serial.print("end");
        }
    }
}
</code></pre><h3 id='custom-record'>Custom record</h3>